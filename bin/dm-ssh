#!/usr/bin/env bash
set -Eeufo pipefail
trap "exit 1" TERM
function helpme {
	if [ $# -gt 0 ]
	then
		echo -e "$1" 1>&2
	else
		grep '#' /proc/$$/fd/255 | sed -n '/^#HELPME_START/,/^#HELPME_END/p' \
			| grep -v "^#HELPME_" | sed "s/#//" | tr -s '\t' 1>&2
	fi
	kill 0
}

function cleanme {
	set +u
	[ -z "$Job" ] ||rm -f $Job $Job-set $Job-exclude $Job-host-* $Job-nodes
	set -u
}

function message {
	[ ! -t 1 ] ||tput setaf 1
	echo $@
	[ ! -t 1 ] ||tput sgr0
}

DmsshConf=~/.dm-ssh.conf
if [ ! -f $DmsshConf ]
then
	DmsshConf=/etc/dm-ssh.conf
	[ -f $DmsshConf ] ||
		helpme "ERR-001: missing config file ~/.dm-ssh.conf or /etc/dm-ssh.conf"
fi
Basename=$(basename $0)
Delay=0
Quiet=No
OptShort="hvle:E:j:d:q"
OptLong="help,version,list,exclude-hosts:,exclude-sets:,jobs:,delay:,quiet"
Opts=$(getopt -o $OptShort --long $OptLong -n $Basename -- "$@")
Job=$(mktemp /tmp/$Basename-XXXX )
[ -n "$Job" ] ||helpme "ERR-007: failed to create temp file"
Parallel=0
echo -n > $Job-exclude
eval set -- "$Opts"
while [ $# -gt 0 ]
do
	case "$1" in
#HELPME_START
#NAME
#	dm-ssh, parallel ssh
#	dm-scp, parallel scp
#SYNOPSIS
#	dm-ssh [OPTION]... [[USER@]SET] -- [CMD [ARGS]]
#	dm-scp [OPTION]... [FILE]... [[USER@]SET]:[DIR]
#EXAMPLE
#	echo -e "set1:\tlocalhost\nset2:\tlocalhost,$HOSTNAME" |tee ~/.dm-ssh.conf #define two host sets
#	dm-ssh -h
#	dm-ssh set1 hostname
#	dm-ssh -e localhost root@set2 -- df -lh
#	touch testfile
#	dm-scp testfile root@set2:/tmp
#	dm-scp -e localhost -- testfile root@set2:/tmp
#DESCRIPTION
		-h |--help)	#print help information
			helpme ;;
		--version)	#print version
			helpme 20240327 ;;
		-v)	#verbose output
			set -x
			shift ;;
		-l |--list)	#list all sets and their hosts
			cat $DmsshConf
			message $DmsshConf
			cleanme
			exit ;;
		-e |--exclude-hosts)	#exclude hosts. E.g. host-1,host-2
			echo $2 |sed "s/,/\n/g" >> $Job-exclude
			shift 2 ;;
		-E |--exclude-sets)	#excluded host sets. E.g. set1,set2
			echo $2 |sed "s/,/\n/g" |while read E
			do
				grep -q ^$E: $DmsshConf ||helpme "ERR-006: exclude-set '$E' doesn't exist"
				grep ^$E: $DmsshConf |cut -d '	' -f 2 |sed "s/,/\n/g" >> $Job-exclude
			done
			shift 2 ;;
		-j |--jobs)	#number of parallel jobs, default 0 means as many as possible
			Parallel=$2
			shift 2 ;;
		-d |--delay)	#NUM, sleep a random fraction of NUM seconds before ssh-ing, default 0
			((Delay=$2))
			shift 2 ;;
		-q |--quiet)	#quiet
			Quiet=Yes
			shift ;;
		--)
			shift 1
			break ;;
		*)
			break ;;
#AUTHOR
#	Manhong Dai, MNI, U of Michigan
#COPYRIGHT
#	Copyright Â© 2002-2023 University of Michigan. MIT License
#HELPME_END
	esac
done
which parallel &> /dev/null ||helpme "ERR-004: missing command 'parallel'"
[ $# -gt 1 ] ||helpme "ERR-002: use -h/--help"
if [ "$Basename" = "dm-ssh" ]
then
	Set=$1
	shift
	Cmd="$@"
	Dir=false
elif [ "$Basename" = "dm-scp" ]
then
	Files=("$@")
	Set=${Files[-1]}
	Cmd=false
	unset 'Files[-1]'
else
	helpme "ERR-010: unsupported mode"
fi
Arr=(${Set//@/ })
case "${#Arr[@]}" in
	1)
		SshUser=$USER ;;
	2)
		SshUser=${Arr[0]}
		Set=${Arr[1]} ;;
	0)
		helpme "ERR-008: set name cannot be empty string";;
	*)
		helpme "ERR-009: set name can have up to one @";;
esac
if [ "$Basename" = "dm-scp" ]
then
	Arr=(${Set//:/ })
	Set=${Arr[0]}
	case "${#Arr[@]}" in
		1)
			Dir="";;
		2)
			Dir=${Arr[1]} ;;
		*)
			helpme "ERR-011: dm-scp TARGET name can only have one :";;
	esac
fi
rm -f $Job-set
[ -z "$Set" ] ||grep ^$Set: $DmsshConf >> $Job-set ||
	helpme "ERR-005: such set \"$Set\" doesn't exist"
[ -s "$Job-set" ] ||helpme "ERR-003: parameter -s or -n is missing"
set +e
if [ "$(join -v 2 <( (grep ^$Set: $DmsshConf |cut -d '	' -f 2 ) |sed "s/,/\n/g" |sort -u ) <(sort -u $Job-exclude) |wc -l )" != "0" ]
then
	join -v 2 <(grep ^$Set: $DmsshConf |cut -d '	' -f 2 |sed "s/,/\n/g" |sort -u ) <(sort -u $Job-exclude)
	read -n 1 -r -p "The hosts above are excluded, but they are not in the node set \"$Set\", you might want to fix your -e/E. continue? [y/N]" yn
	case "$yn" in
		Y|y)
			echo ;;
		N|n)
			echo
			cleanme
			exit 1 ;;
		*)
			helpme "Please answer y or n!";;
	esac
fi
join -v 1 <( cut -d '	' -f 2 $Job-set |sed "s/,/\n/g" |sort -u ) <(sort -u $Job-exclude) > $Job-nodes
MaxWidth=$(cat $Job-nodes |wc -L)
[ "$MaxWidth" -gt 4 ] ||MaxWidth=4
((MaxWidth+=4))
if [ -t 1 ]
then
	TailWidth=$(($(tput cols) - $MaxWidth))
	tabs $MaxWidth
else
	TailWidth=80
	Quiet=Yes
fi
Total=$(cat $Job-nodes |wc -l)
if [ "$Quiet" != "Yes" ]
then
	message "####$Basename####"
fi
[ "$Quiet" = "Yes" ] ||echo -ne "\r1/$Total:\t$(head -n 1 $Job-nodes)"
SshOpts='-o ControlMaster=auto -o ControlPath="~/.ssh/dm-ssh-%r@%n-%p" -o ControlPersist=60 -o ConnectTimeout=2 -o LogLevel=error -o StrictHostKeyChecking=no -o BatchMode=yes' 
seq $Total |parallel -k -j $Parallel --colsep '\t' "
	sleep \$(bc <<< \"scale=3; $Delay*\$RANDOM/32768\" )
	Node=\$(sed '{1}q;d' $Job-nodes)
	if [ $Basename = dm-ssh ]
	then
		ssh $SshOpts $SshUser@\$Node <<< \"$Cmd\" &> $Job-host-\$Node
	else
		scp -qpr $SshOpts ${Files[@]} $SshUser@\$Node:$Dir &> $Job-host-\$Node
	fi
	Rtn=\$?
	Next=\$(({1}+1))
	if [ "$Quiet" = "No" ]
	then
		if [ \$Next -le $Total ]
		then
			echo -ne \"\r\$Next/$Total:\t\"
			head -n \$Next $Job-nodes |tr '\n' ',' |tail -c $TailWidth
		else
			echo -ne \"\r$Total/$Total:\t\"
			cat $Job-nodes |tr '\n' ',' |sed 's/,$/    \n/'
		fi
	fi
	[ -s $Job-host-\$Node ] &&
		[ \"\$(tail -c 1 $Job-host-\$Node |od -iAn |tr -d ' ' )\" != \"10\" ] &&
		echo -e \"\n\" >> $Job-host-\$Node
	echo \$Rtn >> $Job-host-\$Node
"
[ "$Quiet" = "Yes" ] ||message -e "####Output####"
set +f
TailLines=1
while read -r C L
do
	[ "$C" = "$Total" ] ||break
	((TailLines++))
	echo "LINE:$L"
done < <(for F in $Job-host-*; do head -n -1 $F |nl -ba -w1; done |sort -n |uniq -c |sed "s/^ \+//")
FailedHosts=()
SucceededHosts=()
for F in $Job-host-*
do
	Rtn=$(tail -n 1 $F)
	if [ -z "$Rtn" ]
	then
		let Rtn=166
	elif [[ $Rtn =~ ^[0-9]+$ ]]
	then
		let Rtn=$Rtn
	else
		let Rtn=166
	fi
	Node="$(echo $F |sed 's/.*-host-//' )"
	if [ $Rtn = 0 ]
	then
		SucceededHosts+=( $Node )
	else
		FailedHosts+=( $Node )
	fi
	tail -n +$TailLines $F |head -n -1 |sed "s/^/$Rtn:$Node:\t/"
done
set -f
cleanme
IFS=,
if [ "$Quiet" != "Yes" -a ${#SucceededHosts[@]} -gt 0 ]
then
	message "####Succeeded####"
	echo -e "${#SucceededHosts[@]}/$Total:\t${SucceededHosts[*]}"
fi
if [ ${#FailedHosts[@]} -gt 0 ]
then
	message "####Failed####"
	echo -e "${#FailedHosts[@]}/$Total:\t${FailedHosts[*]}"
	[ ! -t 1 ] ||tabs 8
	exit 166
fi
[ ! -t 1 ] ||tabs 8
