#!/usr/bin/env bash
set -Eeufo pipefail
trap "exit 1" TERM
function cleanme {
	set +u
	[ -z "$Job" ] ||rm -f $Job $Job-set $Job-exclude $Job-host-* $Job-nodes
	set -u
}
function message {
	[ ! -t 1 ] ||tput setaf 1
	echo -e $1
	[ ! -t 1 ] ||tput sgr0
}
function helpme {
	cleanme
	if [ $# -gt 0 ]
	then
		echo -e "$1" 1>&2
	else
		grep '#' /proc/$$/fd/255 |
			sed -n '/^#HELPME_START/,/^#HELPME_END/p' |
			grep -v "^#HELPME_" |
			sed "s/#//" |
			tr -s '\t' 1>&2
	fi
	kill -s TERM -- -$(cut -d ' ' -f 5 /proc/$$/stat)
}
DmsshConf=~/.dm-ssh.conf
if [ ! -f $DmsshConf ]
then
	DmsshConf=/etc/dm-ssh.conf
	[ -f $DmsshConf ] ||
		helpme "ERR-001: missing config file ~/.dm-ssh.conf or /etc/dm-ssh.conf"
fi
Delay=0
Timeout=2
Quiet=No
OptShort="hvln:e:E:H:j:d:t:q"
OptLong="help,version,list,include-hosts:,exclude-hosts:,exclude-sets:,header:,jobs:delay:,timeout:,quiet"
Opts=$(getopt -o $OptShort --long $OptLong -n dm-ssh -- "$@")
Job=$(mktemp /tmp/dm-ssh-XXXX )
[ -n "$Job" ] ||helpme "ERR-007: failed to create temp file"
Parallel=0
IncludeHosts=""
echo -n > $Job-exclude
eval set -- "$Opts"
while [ $# -gt 0 ]
do
	case "$1" in
#HELPME_START
#NAME
#	dm-ssh, parallel ssh
#SYNOPSIS
#	dm-ssh [OPTION]...
#EXAMPLE
#	echo -e "set1:\tlocalhost\nset2:\tlocalhost,$HOSTNAME" |tee ~/.dm-ssh.conf #define two host sets
#	dm-ssh -h
#	dm-ssh set1 -- hostname
#	dm-ssh root@set2 -- df -lh
#DESCRIPTION
		-h |--help)	#print help information
			helpme ;;
		--version)	#print version
			helpme 20231118 ;;
		-v )	#verbose output
			set -x
			shift ;;
		-l |--list)	#list all sets and their hosts
			cat $DmsshConf
			message $DmsshConf
			cleanme
			exit ;;
		-n |--include-hosts)	#a list of host name. E.g. host-1,host-2
			IncludeHosts=$2
			shift 2 ;;
		-e |--exclude-hosts)	#exclude hosts. E.g. host-1,host-2
			echo $2 |sed "s/,/\n/g" >> $Job-exclude
			shift 2 ;;
		-E |--exclude-sets)	#excluded host sets. E.g. set1,set2
			echo $2 |sed "s/,/\n/g" |while read E
			do
				grep -q ^$E: $DmsshConf ||helpme "ERR-006: exclude-set '$E' doesn't exist"
				grep ^$E: $DmsshConf |cut -d '	' -f 2 |sed "s/,/\n/g" >> $Job-exclude
			done
			shift 2 ;;
		-j |--jobs)	#number of parallel jobs, default 0 means as many as possible
			Parallel=$2
			shift 2 ;;
		-d |--delay)	#NUM, sleep a random fraction of NUM seconds before ssh-ing, default 0
			((Delay=$2))
			shift 2 ;;
		-t |--timeout)	#SECONDS, ConnectTimeout in ssh, default 2
			((Timeout=$2))
			shift 2 ;;
		-q |--quiet)	#quiet
			Quiet=Yes
			shift ;;
		--)
			shift 1
			break ;;
		*)
			break ;;
#AUTHOR
#	Manhong Dai, MNI, U of Michigan
#COPYRIGHT
#	Copyright Â© 2002-2023 University of Michigan. MIT License
#HELPME_END
	esac
done
which parallel &> /dev/null ||helpme "ERR-004: missing command 'parallel'"
[ $# -gt 1 ] ||helpme "ERR-002: use -h/--help"
Set=$1
Arr=(${Set//@/ })
case "${#Arr[@]}" in
	1 )
		SshUser=$USER ;;
	2 )
		SshUser=${Arr[0]}
		Set=${Arr[1]} ;;
	0 )
		helpme "ERR-008: set name cannot be empty string";;
	* )
		helpme "ERR-009: set name can have up to one @";;
esac
shift
Cmd="$@"
rm -f $Job-set
[ -z "$Set" ] ||grep ^$Set: $DmsshConf >> $Job-set ||helpme "ERR-005: such set doesn't exist"
[ -z "$IncludeHosts" ] ||echo "$IncludeHosts" >> $Job-set
[ -s "$Job-set" ] ||helpme "ERR-003: parameter -s or -n is missing"
set +e
if [ "$Set" != "all" -a "$(join -v 2 <( (grep ^$Set: $DmsshConf |cut -d '	' -f 2 && echo $IncludeHosts ) |sed "s/,/\n/g" |sort -u ) <(sort -u $Job-exclude) |wc -l )" != "0" ]
then
	join -v 2 <(grep ^$Set: $DmsshConf |cut -d '	' -f 2 |sed "s/,/\n/g" |sort -u ) <(sort -u $Job-exclude)
	read -n 1 -r -p "The hosts above are excluded, but they are not in the node set \"$Set\", you might want to fix your -e/E. continue? [y/N]" yn
	case "$yn" in
		Y|y )
			echo ;;
		N|n )
			echo
			cleanme
			exit 1 ;;
		* )
			helpme "Please answer y or n!";;
	esac
fi
join -v 1 <( cut -d '	' -f 2 $Job-set |sed "s/,/\n/g" |sort -u ) <(sort -u $Job-exclude) > $Job-nodes
if [ "$Quiet" != "Yes" ]
then
	message "####Ssh####"
	echo -ne "..$(head -n 1 $Job-nodes)\r"
fi
paste <(cat $Job-nodes) <(tail -n +2 $Job-nodes; echo DONE ) |parallel -k -j $Parallel --colsep '\t' "
	sleep \$(bc <<< \"scale=3; $Delay*\$RANDOM/32768\" );
	ssh -o ControlMaster=auto -o ControlPath=~/.ssh/dm-ssh-%r%n-%p -o ControlPersist=60  -o ConnectTimeout=$Timeout -o LogLevel=error -o StrictHostKeyChecking=no -o BatchMode=yes -n $SshUser@{1} \"$Cmd\" &> $Job-host-{1};
	Rtn=\$?;
	[ "$Quiet" = "Yes" ] ||echo -n -e \"\$Rtn:{1} \n..{2}\r\";
	[ -s $Job-host-{1} ] &&
		[ \"\$(tail -c 1 $Job-host-{1} |od -iAn |tr -d ' ' )\" != \"10\" ] &&
		echo -e \"\n\" >> $Job-host-{1};
	echo \$Rtn >> $Job-host-{1};
"
[ ! -t 1 ] ||tabs 16
[ "$Quiet" = "Yes" ] ||message "####Output####"
set +f
Nodes=$(cat $Job-nodes |wc -l)
TailLines=1
while read C L
do
	[ "$C" = "$Nodes" ] ||break
	((TailLines++))
	echo "COMMON:$L"
done < <(for F in $Job-host-*; do head -n -1 $F |nl -ba -w1; done |sort -n |uniq -c |sed -e "s/^ \+//")
FailedHosts=()
Succeeded=0
for F in $Job-host-*
do
	Rtn=$(tail -n 1 $F)
	if [ -z "$Rtn" ]
	then
		let Rtn=9
	elif [[ $Rtn =~ ^[0-9]+$ ]]
	then
		let Rtn=$Rtn
	else
		let Rtn=9
	fi
	if [ $Rtn = 0 ]
	then
		((Succeeded++))
	else
		FailedHosts+=( $( basename $F |cut -d - -f 5-))
	fi
	Host="$(echo $F |sed 's/.*-host-//' )"
	tail -n +$TailLines $F |head -n -1 |sed "s/^/$Rtn:$Host:\t/"
done
set -f
[ ! -t 1 ] ||tabs 8
cleanme
message "####Succeeded: $Succeeded"
[ ${#FailedHosts[@]} -gt 0 ] && message "####Failed: ${#FailedHosts[@]}" && echo "${FailedHosts[*]}"
[ ${#FailedHosts[@]} -eq 0 ]
